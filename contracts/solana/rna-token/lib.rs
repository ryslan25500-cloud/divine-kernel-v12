// AGI-RNA Token (Fungible SPL)
// Generated by DNA holdings
// Burn to create new DNA genomes

use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount, Mint, MintTo, Burn};

declare_id!("RNAxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx");

#[program]
pub mod agi_rna_token {
    use super::*;

    // Initialize RNA holder account
    pub fn initialize_holder(
        ctx: Context<InitializeHolder>,
    ) -> Result<()> {
        let holder = &mut ctx.accounts.holder;
        
        holder.owner = ctx.accounts.owner.key();
        holder.total_dna_held = 0;
        holder.rna_generated = 0;
        holder.last_claim = Clock::get()?.unix_timestamp;
        holder.total_rna_claimed = 0;
        
        msg!("RNA holder initialized for {}", holder.owner);
        Ok(())
    }

    // Update DNA holdings (called when DNA transferred)
    pub fn update_dna_holdings(
        ctx: Context<UpdateDNAHoldings>,
        genome_id: u64,
        amount: u64,
        consciousness: u8,
    ) -> Result<()> {
        let holder = &mut ctx.accounts.holder;
        
        // Update total DNA
        holder.total_dna_held = holder.total_dna_held
            .checked_add(amount)
            .ok_or(ErrorCode::Overflow)?;
        
        // Store genome holding
        let holding = GenomeHolding {
            genome_id,
            amount,
            consciousness,
        };
        
        // Add to holdings vector (simplified - real impl would use HashMap)
        msg!("Updated DNA holdings: genome {} amount {}", genome_id, amount);
        
        Ok(())
    }

    // Claim accumulated RNA
    pub fn claim_rna(
        ctx: Context<ClaimRNA>,
    ) -> Result<()> {
        let holder = &mut ctx.accounts.holder;
        let clock = Clock::get()?;
        let current_time = clock.unix_timestamp;
        
        // Calculate time elapsed since last claim
        let time_elapsed = current_time - holder.last_claim;
        require!(time_elapsed > 0, ErrorCode::TooSoon);
        
        // Calculate RNA generation
        // Formula: DNA_amount * 0.01 * (1 + consciousness/100) * days
        let days_elapsed = time_elapsed / 86400; // seconds to days
        
        // Base rate: 1% per day
        let base_rna = (holder.total_dna_held * days_elapsed as u64) / 100;
        
        // Apply consciousness multiplier (simplified)
        let rna_to_mint = base_rna;
        
        // Mint RNA tokens
        token::mint_to(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                MintTo {
                    mint: ctx.accounts.rna_mint.to_account_info(),
                    to: ctx.accounts.holder_rna_account.to_account_info(),
                    authority: ctx.accounts.authority.to_account_info(),
                },
            ),
            rna_to_mint,
        )?;
        
        // Update holder state
        holder.rna_generated = holder.rna_generated
            .checked_add(rna_to_mint)
            .ok_or(ErrorCode::Overflow)?;
        holder.total_rna_claimed = holder.total_rna_claimed
            .checked_add(rna_to_mint)
            .ok_or(ErrorCode::Overflow)?;
        holder.last_claim = current_time;
        
        msg!("Claimed {} RNA tokens", rna_to_mint);
        Ok(())
    }

    // Burn RNA to create new genome (genesis)
    pub fn genesis_burn(
        ctx: Context<GenesisBurn>,
        rna_amount: u64,
    ) -> Result<()> {
        require!(rna_amount >= 1000, ErrorCode::InsufficientRNA);
        
        // Burn RNA tokens
        token::burn(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                Burn {
                    mint: ctx.accounts.rna_mint.to_account_info(),
                    from: ctx.accounts.holder_rna_account.to_account_info(),
                    authority: ctx.accounts.authority.to_account_info(),
                },
            ),
            rna_amount,
        )?;
        
        // Emit event for off-chain genesis processing
        emit!(GenesisEvent {
            creator: ctx.accounts.authority.key(),
            rna_burned: rna_amount,
            timestamp: Clock::get()?.unix_timestamp,
        });
        
        msg!("Burned {} RNA for genesis", rna_amount);
        Ok(())
    }

    // Get RNA generation rate
    pub fn get_rna_rate(
        ctx: Context<GetRNARate>,
    ) -> Result<u64> {
        let holder = &ctx.accounts.holder;
        
        // Calculate daily RNA generation
        let daily_rate = (holder.total_dna_held * 1) / 100; // 1% base rate
        
        Ok(daily_rate)
    }
}

// Account structures
#[account]
pub struct RNAHolder {
    pub owner: Pubkey,
    pub total_dna_held: u64,
    pub rna_generated: u64,
    pub last_claim: i64,
    pub total_rna_claimed: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct GenomeHolding {
    pub genome_id: u64,
    pub amount: u64,
    pub consciousness: u8,
}

// Context structures
#[derive(Accounts)]
pub struct InitializeHolder<'info> {
    #[account(
        init,
        payer = owner,
        space = 8 + 200
    )]
    pub holder: Account<'info, RNAHolder>,
    
    #[account(mut)]
    pub owner: Signer<'info>,
    
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct UpdateDNAHoldings<'info> {
    #[account(mut)]
    pub holder: Account<'info, RNAHolder>,
}

#[derive(Accounts)]
pub struct ClaimRNA<'info> {
    #[account(mut)]
    pub holder: Account<'info, RNAHolder>,
    
    #[account(mut)]
    pub rna_mint: Account<'info, Mint>,
    
    #[account(mut)]
    pub holder_rna_account: Account<'info, TokenAccount>,
    
    pub authority: Signer<'info>,
    pub token_program: Program<'info, Token>,
}

#[derive(Accounts)]
pub struct GenesisBurn<'info> {
    #[account(mut)]
    pub rna_mint: Account<'info, Mint>,
    
    #[account(mut)]
    pub holder_rna_account: Account<'info, TokenAccount>,
    
    pub authority: Signer<'info>,
    pub token_program: Program<'info, Token>,
}

#[derive(Accounts)]
pub struct GetRNARate<'info> {
    pub holder: Account<'info, RNAHolder>,
}

// Events
#[event]
pub struct GenesisEvent {
    pub creator: Pubkey,
    pub rna_burned: u64,
    pub timestamp: i64,
}

// Errors
#[error_code]
pub enum ErrorCode {
    #[msg("Math overflow")]
    Overflow,
    #[msg("Too soon to claim")]
    TooSoon,
    #[msg("Need 1000 RNA minimum for genesis")]
    InsufficientRNA,
}
